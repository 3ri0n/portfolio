<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Typing Test</title>
  <style>
    :root{
      --bg:#0b0e16; --panel:#0f1423; --panel-2:#121a2e; --text:#eaf1ff; --muted:#9aa3b2;
      --accent:#ffa500; --bad:#ff6464; --ring: rgba(255,165,0,.5);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:
        radial-gradient(1200px 800px at 80% 120%, #1a1f2b 0%, #0b0e16 60%),
        linear-gradient(135deg, #0b0e16 0%, #0d1222 100%);
      color:var(--text);
      font:16px/1.55 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;
      overflow:hidden;
    }
    .topbar{display:flex;align-items:center;gap:12px;padding:12px 16px;position:sticky;top:0;z-index:3;
      background:linear-gradient(180deg, rgba(11,14,22,.9), rgba(11,14,22,.6) 70%, transparent);
      backdrop-filter: blur(8px);border-bottom:1px solid rgba(255,255,255,.06)}
    .chip{background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.1);color:var(--muted);
      padding:6px 10px;border-radius:999px;font-size:13px;cursor:pointer;user-select:none}
    .chip.active{color:var(--text);border-color:rgba(255,255,255,.25)}
    .spacer{flex:1}
    .btn{appearance:none;border:0;border-radius:12px;cursor:pointer;background:var(--panel-2);
      color:var(--text);padding:10px 14px;font-weight:600;border:1px solid rgba(255,255,255,.08)}
    .btn-ghost{background:transparent;border-color:rgba(255,255,255,.14);color:var(--muted)}
    .btn:active{transform:translateY(1px)}

    .stats{display:flex;gap:14px;align-items:center;justify-content:center;margin:8px 0 0;padding:0 16px;flex-wrap:wrap}
    .stat{background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.08);padding:12px 16px;border-radius:14px;min-width:120px;text-align:center;
      box-shadow: 0 6px 24px rgba(0,0,0,.25), inset 0 0 0 1px rgba(255,255,255,.05)}
    .stat .label{font-size:12px;color:var(--muted)} .stat .value{font-size:24px;font-weight:800;letter-spacing:.3px}

    .bar-wrap{width:min(980px, 92vw); margin: 2px auto 0; height:6px; border-radius:999px;
      background:rgba(255,255,255,.06); overflow:hidden; box-shadow: inset 0 0 0 1px rgba(255,255,255,.06)}
    .bar{height:100%; width:0%; background: linear-gradient(90deg, #ffb347, #ffcc33); transition: width .2s}

    .arena{max-width:980px;margin:20px auto 0;padding:0 16px;height:calc(100% - 176px);
      display:flex;flex-direction:column;align-items:center;gap:12px}
    .text-wrap{position:relative;background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border:1px solid rgba(255,255,255,.08);border-radius:18px;padding:26px 24px;width:100%;height:100%;overflow:auto;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02), 0 14px 50px rgba(0,0,0,.35)}
    .text{font-size:22px; line-height:1.95; user-select:none; white-space:pre-wrap}
    .c{opacity:.48} .c.ok{opacity:1} .c.bad{opacity:1;color:var(--bad); text-decoration:underline wavy} .c.extra{opacity:.95; color:var(--bad); text-decoration:underline wavy}

    .caret{position:absolute;width:2px;height:1.4em;background:var(--accent);box-shadow:0 0 14px var(--ring);
      transform:translate(0,4px);animation:blink 1s infinite; pointer-events:none}
    @keyframes blink{50%{opacity:.2}}

    #back-glow{position:fixed; bottom:20px; right:20px; width:64px;height:64px;border-radius:50%;
      background:transparent; box-shadow:0 0 22px 12px rgba(255,165,0,.6);animation:pulse 2s infinite; z-index:10; border:0;cursor:pointer}
    @keyframes pulse{0%,100%{box-shadow:0 0 22px 12px rgba(255,165,0,.6)}50%{box-shadow:0 0 34px 18px rgba(255,165,0,.9)}}
    @media (max-width:700px){ .text{font-size:19px} .stat .value{font-size:20px} }
  </style>
</head>
<body>
  <div class="topbar">
    <div id="modes">
      <span class="chip active" data-time="15">15s</span>
      <span class="chip" data-time="30">30s</span>
      <span class="chip" data-time="60">60s</span>
    </div>
    <div class="spacer"></div>
    <button id="newText" class="btn btn-ghost" title="Load new text">New text</button>
    <button id="restart" class="btn" title="Restart test">Restart</button>
    <button id="focus" class="btn btn-ghost" title="Focus typing">Focus</button>
  </div>

  <div class="stats">
    <div class="stat"><div class="label">Time</div><div class="value" id="time">15</div></div>
    <div class="stat"><div class="label">WPM</div><div class="value" id="wpm">0</div></div>
    <div class="stat"><div class="label">Accuracy</div><div class="value" id="acc">100%</div></div>
    <div class="stat"><div class="label">Chars</div><div class="value" id="chars">0/0</div></div>
  </div>

  <div class="bar-wrap"><div class="bar" id="bar"></div></div>

  <div class="arena">
    <div class="text-wrap" id="wrap">
      <div class="text" id="text"></div>
      <div class="caret" id="caret" style="left:0;top:0"></div>
    </div>
  </div>

  <a id="back-glow" href="index.html" aria-label="Back to home" title="Back to home"></a>
  <input id="hiddenInput" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"
         style="position:absolute;opacity:0;pointer-events:none;height:0;width:0" />

  <script>
  // ---------- load sentences (offline .txt) ----------
  async function loadSentences(){
    const res = await fetch('./sentences.txt?v=' + Date.now(), {cache:'no-store'});
    if(!res.ok){
      alert('sentences.txt not found next to minigame.html');
      return ["Please add a sentences.txt file with one sentence per line."];
    }
    const lines = (await res.text()).split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    // dedupe
    return Array.from(new Set(lines));
  }

  // ---------- deck utilities (no-repeat random draw) ----------
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  let sentencePool = [];        // strings
  let deck = [];                // array of indices into sentencePool
  let deckPos = 0;              // current pointer

  function rebuildDeck(){
    deck = Array.from({length: sentencePool.length}, (_,i)=>i);
    shuffle(deck);
    // start at a random point so restart/newText don't look similar
    deckPos = Math.floor(Math.random() * (deck.length || 1));
  }
  function drawSentences(count){
    const out = [];
    if (sentencePool.length === 0) return out;
    for(let k=0;k<count;k++){
      if(deckPos >= deck.length){ shuffle(deck); deckPos = 0; } // reshuffle when exhausted
      const idx = deck[deckPos++];
      out.push(sentencePool[idx]);
    }
    return out;
  }

  // ---------- typing UI ----------
  const wrap = document.getElementById('wrap');
  const textEl = document.getElementById('text');
  const caretEl = document.getElementById('caret');
  const hiddenInput = document.getElementById('hiddenInput');

  const timeEl = document.getElementById('time');
  const wpmEl  = document.getElementById('wpm');
  const accEl  = document.getElementById('acc');
  const charsEl= document.getElementById('chars');
  const barEl  = document.getElementById('bar');

  const restartBtn = document.getElementById('restart');
  const focusBtn   = document.getElementById('focus');
  const newTextBtn = document.getElementById('newText');
  const modes = document.getElementById('modes');

  let testSeconds = 15, timeLeft = testSeconds, timer = null, startedAt = null;
  let currentIndex = 0, correctChars = 0, totalTyped = 0;

  function appendText(text){
    for(const ch of text){
      const s=document.createElement('span'); s.className='c'; s.textContent=ch; textEl.appendChild(s);
    }
  }
  function paragraph(count=5){
    const parts = drawSentences(count);
    const p = parts.join(' ') + ' ';
    return p;
  }
  async function ensureBuffer(){
    const spans=textEl.querySelectorAll('.c');
    const remaining=spans.length-currentIndex;
    if(remaining<180){ appendText(paragraph(6)); }
  }
  function moveCaret(){
    const spans=textEl.querySelectorAll('.c');
    const i=Math.min(currentIndex,spans.length-1);
    const ref=spans[i]; if(!ref) return;
    const r=ref.getBoundingClientRect(), wr=wrap.getBoundingClientRect();
    caretEl.style.left=(r.left-wr.left)+'px'; caretEl.style.top=(r.top-wr.top)+'px';
    const caretBottom=r.bottom-wr.top+wrap.scrollTop, caretTop=r.top-wr.top+wrap.scrollTop;
    if(caretBottom>wrap.scrollTop+wrap.clientHeight-40){ wrap.scrollTop=caretBottom-wrap.clientHeight+60; }
    else if(caretTop<wrap.scrollTop+40){ wrap.scrollTop=Math.max(0, caretTop-60); }
  }
  function focusTyping(){ hiddenInput.focus(); setTimeout(moveCaret,10); }

  function startTimer(){ if(timer) return; startedAt=Date.now();
    timer=setInterval(()=>{ timeLeft=Math.max(0, testSeconds-Math.floor((Date.now()-startedAt)/1000));
      timeEl.textContent=timeLeft; barEl.style.width=((testSeconds-timeLeft)/testSeconds*100).toFixed(1)+'%';
      updateStats(); if(timeLeft<=0){ endTest(); }
    },200);
  }
  function updateStats(){
    const elapsed=Math.max(1,(Date.now()-(startedAt||Date.now()))/1000);
    const wpm=Math.round(((correctChars)/5)/(elapsed/60));
    const acc= totalTyped? Math.max(0,Math.round((correctChars/totalTyped)*100)) : 100;
    wpmEl.textContent=isFinite(wpm)?wpm:0; accEl.textContent=acc+'%'; charsEl.textContent=correctChars+'/'+totalTyped;
  }
  function endTest(){
    clearInterval(timer); timer=null; hiddenInput.blur();
    const spans=textEl.querySelectorAll('.c');
    for(let i=currentIndex;i<spans.length;i++){ spans[i].style.opacity=.25; }
  }

  async function reloadPool(){
    sentencePool = await loadSentences();   // from sentences.txt
    rebuildDeck();                          // new random deck every load
  }
  async function restart(){
    clearInterval(timer); timer=null; startedAt=null; timeLeft=testSeconds; timeEl.textContent=testSeconds; barEl.style.width='0%';
    textEl.innerHTML=''; currentIndex=0; correctChars=0; totalTyped=0;

    if(!sentencePool.length){ await reloadPool(); } 
    // randomize starting position each restart for variety
    if(deck.length) deckPos = Math.floor(Math.random()*deck.length);

    appendText(paragraph(6));
    await ensureBuffer();
    moveCaret();
    updateStats();
    focusTyping();
  }
  function markSpan(i, cls, hit=true){
    const s=textEl.querySelectorAll('.c')[i]; if(!s) return;
    s.classList.remove('ok','bad','extra'); if(cls) s.classList.add(cls); if(hit) s.dataset.hit='1';
  }

  hiddenInput.addEventListener('keydown', async (e)=>{
    if(timeLeft<=0){ e.preventDefault(); return; }
    if(e.key==='Tab'){ e.preventDefault(); return; }
    if(!startedAt && e.key.length===1){ startTimer(); }

    if(e.key==='Backspace'){
      if(currentIndex>0){
        currentIndex--;
        const s=textEl.querySelectorAll('.c')[currentIndex];
        if(s && s.dataset.hit==='1'){
          totalTyped--; if(s.classList.contains('ok')) correctChars--;
          s.classList.remove('ok','bad','extra'); s.removeAttribute('data-hit');
          updateStats();
        }else{
          const extras=textEl.querySelectorAll('.c.extra');
          if(extras.length){ extras[extras.length-1].remove(); totalTyped--; updateStats(); }
        }
        moveCaret();
      }
      e.preventDefault(); return;
    }

    if(e.key==='Enter'){
      const spans=textEl.querySelectorAll('.c');
      const expected=spans[currentIndex]?.textContent;
      if (expected === "\n") {
        markSpan(currentIndex,'ok'); correctChars++; totalTyped++;
        currentIndex++; updateStats(); moveCaret();
      }
      e.preventDefault(); return;
    }

    if(e.key.length===1 && !e.ctrlKey && !e.metaKey){
      const spans=textEl.querySelectorAll('.c');
      const expected=spans[currentIndex]?.textContent;
      if(expected===undefined){
        const extra=document.createElement('span'); extra.className='c extra'; extra.textContent=e.key;
        textEl.appendChild(extra); totalTyped++; currentIndex++;
      }else{
        if(e.key===expected){ markSpan(currentIndex,'ok'); correctChars++; }
        else { markSpan(currentIndex,'bad'); }
        totalTyped++; currentIndex++;
      }
      updateStats(); moveCaret(); await ensureBuffer();
      e.preventDefault();
    }
  });

  // controls
  focusBtn.addEventListener('click', focusTyping);
  wrap.addEventListener('click', focusTyping);
  restartBtn.addEventListener('click', restart);
  newTextBtn.addEventListener('click', async ()=>{
    await reloadPool();       // fresh deck + random start
    await restart();
  });
  modes.addEventListener('click', async (e)=>{
    const chip=e.target.closest('.chip'); if(!chip) return;
    [...modes.querySelectorAll('.chip')].forEach(c=>c.classList.remove('active'));
    chip.classList.add('active'); testSeconds=+chip.dataset.time;
    await restart();
  });

  (async()=>{ await reloadPool(); await restart(); })();
  </script>
</body>
</html>
